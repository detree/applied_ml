wdat_data<-t(t(wdat_offsets)/wdat_sd)
#seperate train test and validation data and result
train_ind<-createDataPartition(y = wdat_result,p = 0.8/0.9,list =FALSE)
train_result <- wdat_result [train_ind]
train_data <- wdat_data[train_ind,]
validation_result<-wdat_result[-train_ind]
validation_data <- wdat_data[-train_ind,]
#test_result <- no_train_result[test_ind]
#test_data <- no_train_data[test_ind,]
true_cnt<-0
#beginning training
for(try_lenta in 1:4){
lenta = 1/(10^(try_lenta - 1))
a <- c(1, -3, 2, 1, -4, 5)
b <- 10
for(epoch in 1:50){
the_p = 50/length(train_result)
plot_ind<-createDataPartition(y = train_result,p = the_p,list =FALSE)
plot_data <- train_data[plot_ind,]
plot_result <- train_result[plot_ind]
steplength <- 1/(x * epoch + y)
for(step in 1:300){
selected <- sample(1:length(train_data[,1]),1)
selected_data <- train_data[selected,]
training_Answer[1] <-	train_result[selected] == " >50K"
training_Answer[2] <- train_result[selected] == " <=50K"
predict<-selected_data * a
#	print(predict)
predict <- yi[training_Answer] * (sum(predict) + b)
#	print(predict)
predict <- predict >= 1
#	print(predict)
#	print(is_more_than_50)
#	print(predict)
#print(" ")
if(predict){
#true_cnt<-true_cnt+1
delta_a <- lenta * a
delta_b <- 0
}
else{
delta_a <- lenta * a -  yi[training_Answer] * selected_data
# print(yi[training_Answer])
delta_b <- -yi[training_Answer]
}
a <- a - delta_a * steplength
b <- b - delta_b * steplength
if(step %% 30 == 0)
{
plot_predict<-t(t(plot_data)*a)
plot_predict<-rowSums(plot_predict) + b
plot_predict<-plot_predict > 0
plot_Answer <- plot_result == " >50K"
plot_accuracy <- plot_predict == plot_Answer
plot_accuracy <- sum(plot_accuracy)/length(plot_accuracy)
plot[try_lenta,(300 * (epoch - 1) + step)/30] <- plot_accuracy
}
}
}
validation_predict<-t(t(validation_data)*a)
validation_predict<-rowSums(validation_predict) + b
validation_predict<-validation_predict > 0
validation_Answer <- validation_result == " >50K"
val_accuracy <- validation_predict == validation_Answer
val_accuracy <- sum(val_accuracy)/length(val_accuracy)
if(val_accuracy > pre_accuracy)
{
pre_accuracy <- val_accuracy
result_a <- a
result_b <- b
}
}
plot(1:length(plot[1,]),plot[1,],type = "l",	ylab="accuracy",ylim=c(0,1))
lines(1:length(plot[2,]),plot[2,],type = "l",col="red")
lines(1:length(plot[3,]),plot[3,],type = "l",col="green")
lines(1:length(plot[4,]),plot[4,],type = "l",col="gray")
#test_data
testdat<-read.csv('test.txt',header = FALSE)
testdat_con <- testdat[index]
test_data <- testdat_con[,-c(7)]
test_result <- testdat_con[,7]
test_data<-scale(test_data)
test_predict<-t(t(test_data)*result_a)
test_predict<-rowSums(test_predict) + result_b
test_predict<-test_predict > 0
test_Answer <- test_result == " >50K."
accuracy <- test_predict == test_Answer
accuracy <- sum(accuracy)/length(accuracy)
accuracy
setwd("/Users/Lunan/Documents/CS498/HW2")
rm(list=ls())
library(klaR)
library(caret)
#---------------initialize varablie-----------------------
a <- 0.05
b <- 100
epoch <- 50
step <- 300
main_a<-runif(6, -2, 2)
main_b<-runif(1, -2, 2)
answer <- c(TRUE, FALSE)
number <- c(1, -1)
train_accuracy <- 0
graph_size = 50 * 300 / 30
graph <- matrix(data=NA,nrow=4,ncol=graph_size)
#--------------------end------------------------------------
whole_file <- read.csv('data.txt', header = FALSE)
whole_data <- whole_file[, c(1, 3, 5, 11, 12, 13)]
whole_result <- whole_file[, 15]
file_idx<-createDataPartition(y = whole_result,p = 0.9,list =FALSE)
cont_data <- whole_data[file_idx, ]
cont_result <- whole_result[file_idx]
test_data <- whole_data[-file_idx, ]
test_result <- whole_result[-file_idx]
test_data<-scale(test_data)
#-------------------normal distribution----------------------
cont_mean <- sapply(cont_data,mean)
cont_sd <- sapply(cont_data,sd)
cont_offset <- t(t(cont_data)-cont_mean)
cont_data<-t(t(cont_offset)/cont_sd)
#----------------------end------------------------------------
# separate trainning and validation data
train_ind <- createDataPartition(y = cont_result,p = 0.8/0.9,list =FALSE)
train_data <- cont_data[train_ind,]
train_result <- cont_result[train_ind]
valid_data <- cont_data[-train_ind,]
valid_result <- cont_result[-train_ind]
#print(train_data[,1])
for(i in 0:-3){
lambda = 10^i
#print(lambda)
for(j in 1:epoch){
step_len <- 1/(a*j+b)
#-----------------------drawing graph prepare--------------------------
p_rate = 50/nrow(train_data)
graph_idx<-createDataPartition(y = train_result, p = p_rate, list =FALSE)
graph_data <- train_data[graph_idx,]
graph_result <- train_result[graph_idx]
#--------------------------------------------------------------
for(k in 1:step){
select_idx <- sample(1:length(train_data[,1]), 1)
select_data <- train_data[select_idx,]
answer[1] <- train_result[select_idx] == " >50K"
answer[2] <- train_result[select_idx] == " <=50K"
predict<-select_data * main_a
predict <- number[answer] * (sum(predict) + main_b)
predict <- predict >= 1
if(predict){
delta_a <- lambda * main_a
delta_b <- 0
}
else{
delta_a <- lambda * main_a -  number[answer] * select_data
delta_b <- -number[answer]
}
main_a <- main_a - delta_a * step_len
main_b <- main_b - delta_b * step_len
#-------------------------------drawing graph data----------------------------
if(k %% 30 == 0)
{
graph_predict <- t(t(graph_data)*main_a)
graph_predict <- rowSums(graph_predict) + main_b
graph_predict <- graph_predict > 0
graph_answer <- graph_result == " >50K"
graph_accuracy <- graph_predict == graph_answer
graph_accuracy <- sum(graph_accuracy)/length(graph_accuracy)
graph[lambda,(300 * (i - 1) + k)/30] <- graph_accuracy
}
#------------------------------end------------------------------------------------
}#end of 300 steps
valid_predict<-t(t(valid_data)*main_a)
valid_predict<-rowSums(valid_predict) + main_b
valid_predict<-valid_predict > 0
valid_answer <- valid_result == " >50K"
val_accuracy <- valid_predict == valid_answer
val_accuracy <- sum(val_accuracy)/length(val_accuracy)
if(val_accuracy > train_accuracy)
{
train_accuracy <- val_accuracy
result_a <- main_a
result_b <- main_b
}
}#end of 50 epoches
}#end of 10^i
setwd("/Users/Lunan/Documents/CS498/HW2")
rm(list=ls())
library(klaR)
library(caret)
#---------------initialize varablie-----------------------
a <- 0.05
b <- 100
epoch <- 50
step <- 300
main_a<-runif(6, -2, 2)
main_b<-runif(1, -2, 2)
answer <- c(TRUE, FALSE)
number <- c(1, -1)
train_accuracy <- 0
graph_size = 50 * 300 / 30
graph <- matrix(data=NA,nrow=4,ncol=graph_size)
#--------------------end------------------------------------
whole_file <- read.csv('data.txt', header = FALSE)
whole_data <- whole_file[, c(1, 3, 5, 11, 12, 13)]
whole_result <- whole_file[, 15]
file_idx<-createDataPartition(y = whole_result,p = 0.9,list =FALSE)
cont_data <- whole_data[file_idx, ]
cont_result <- whole_result[file_idx]
test_data <- whole_data[-file_idx, ]
test_result <- whole_result[-file_idx]
test_data<-scale(test_data)
#-------------------normal distribution----------------------
cont_mean <- sapply(cont_data,mean)
cont_sd <- sapply(cont_data,sd)
cont_offset <- t(t(cont_data)-cont_mean)
cont_data<-t(t(cont_offset)/cont_sd)
#----------------------end------------------------------------
# separate trainning and validation data
train_ind <- createDataPartition(y = cont_result,p = 0.8/0.9,list =FALSE)
train_data <- cont_data[train_ind,]
train_result <- cont_result[train_ind]
valid_data <- cont_data[-train_ind,]
valid_result <- cont_result[-train_ind]
#print(train_data[,1])
for(i in 0:-3){
lambda = 10^i
#print(lambda)
for(j in 1:epoch){
step_len <- 1/(a*j+b)
#-----------------------drawing graph prepare--------------------------
p_rate = 50/nrow(train_data)
graph_idx<-createDataPartition(y = train_result, p = p_rate, list =FALSE)
graph_data <- train_data[graph_idx,]
graph_result <- train_result[graph_idx]
#--------------------------------------------------------------
for(k in 1:step){
select_idx <- sample(1:length(train_data[,1]), 1)
select_data <- train_data[select_idx,]
answer[1] <- train_result[select_idx] == " >50K"
answer[2] <- train_result[select_idx] == " <=50K"
predict<-select_data * main_a
predict <- number[answer] * (sum(predict) + main_b)
predict <- predict >= 1
if(predict){
delta_a <- lambda * main_a
delta_b <- 0
}
else{
delta_a <- lambda * main_a -  number[answer] * select_data
delta_b <- -number[answer]
}
main_a <- main_a - delta_a * step_len
main_b <- main_b - delta_b * step_len
#-------------------------------drawing graph data----------------------------
if(k %% 30 == 0)
{
graph_predict <- t(t(graph_data)*main_a)
graph_predict <- rowSums(graph_predict) + main_b
graph_predict <- graph_predict > 0
graph_answer <- graph_result == " >50K"
graph_accuracy <- graph_predict == graph_answer
graph_accuracy <- sum(graph_accuracy)/length(graph_accuracy)
graph[lambda,(300 * (j - 1) + k)/30] <- graph_accuracy
}
#------------------------------end------------------------------------------------
}#end of 300 steps
valid_predict<-t(t(valid_data)*main_a)
valid_predict<-rowSums(valid_predict) + main_b
valid_predict<-valid_predict > 0
valid_answer <- valid_result == " >50K"
val_accuracy <- valid_predict == valid_answer
val_accuracy <- sum(val_accuracy)/length(val_accuracy)
if(val_accuracy > train_accuracy)
{
train_accuracy <- val_accuracy
result_a <- main_a
result_b <- main_b
}
}#end of 50 epoches
}#end of 10^i
#---------------------start testing now--------------------------------
test_predict<-t(t(test_data)*result_a)
test_predict<-rowSums(test_predict) + result_b
test_predict<-test_predict > 0
test_answer <- test_result == " >50K"
accuracy <- test_predict == test_answer
accuracy <- sum(accuracy)/length(accuracy)
accuracy
#-----------------------------------------------------------------------
#----------------------drawing graph------------------------------------
plot(1:length(graph[1,]),graph[1,],type = "l",	ylab="accuracy",ylim=c(0,1))
lines(1:length(graph[2,]),graph[2,],type = "l",col="red")
lines(1:length(graph[3,]),graph[3,],type = "l",col="green")
lines(1:length(graph[4,]),graph[4,],type = "l",col="gray")
#------------------------end of the program------------------------------
setwd("/Users/Lunan/Documents/CS498/HW2")
rm(list=ls())
library(klaR)
library(caret)
#---------------initialize varablie-----------------------
a <- 0.05
b <- 100
epoch <- 50
step <- 300
main_a<-c(1, -3, 2, 1, -4, 5)#runif(6, -2, 2)
main_b<-10#runif(1, -2, 2)
answer <- c(TRUE, FALSE)
number <- c(1, -1)
train_accuracy <- 0
graph_size = 50 * 300 / 30
graph <- matrix(data=NA,nrow=4,ncol=graph_size)
#--------------------end------------------------------------
whole_file <- read.csv('data.txt', header = FALSE)
whole_data <- whole_file[, c(1, 3, 5, 11, 12, 13)]
whole_result <- whole_file[, 15]
file_idx<-createDataPartition(y = whole_result,p = 0.9,list =FALSE)
cont_data <- whole_data[file_idx, ]
cont_result <- whole_result[file_idx]
test_data <- whole_data[-file_idx, ]
test_result <- whole_result[-file_idx]
test_data<-scale(test_data)
#-------------------normal distribution----------------------
cont_mean <- sapply(cont_data,mean)
cont_sd <- sapply(cont_data,sd)
cont_offset <- t(t(cont_data)-cont_mean)
cont_data<-t(t(cont_offset)/cont_sd)
#----------------------end------------------------------------
# separate trainning and validation data
train_ind <- createDataPartition(y = cont_result,p = 0.8/0.9,list =FALSE)
train_data <- cont_data[train_ind,]
train_result <- cont_result[train_ind]
valid_data <- cont_data[-train_ind,]
valid_result <- cont_result[-train_ind]
#print(train_data[,1])
for(i in 0:-3){
lambda = 10^i
#print(lambda)
for(j in 1:epoch){
step_len <- 1/(a*j+b)
#-----------------------drawing graph prepare--------------------------
p_rate = 50/nrow(train_data)
graph_idx<-createDataPartition(y = train_result, p = p_rate, list =FALSE)
graph_data <- train_data[graph_idx,]
graph_result <- train_result[graph_idx]
#--------------------------------------------------------------
for(k in 1:step){
select_idx <- sample(1:length(train_data[,1]), 1)
select_data <- train_data[select_idx,]
answer[1] <- train_result[select_idx] == " >50K"
answer[2] <- train_result[select_idx] == " <=50K"
predict<-select_data * main_a
predict <- number[answer] * (sum(predict) + main_b)
predict <- predict >= 1
if(predict){
delta_a <- lambda * main_a
delta_b <- 0
}
else{
delta_a <- lambda * main_a -  number[answer] * select_data
delta_b <- -number[answer]
}
main_a <- main_a - delta_a * step_len
main_b <- main_b - delta_b * step_len
#-------------------------------drawing graph data----------------------------
if(k %% 30 == 0)
{
graph_predict <- t(t(graph_data)*main_a)
graph_predict <- rowSums(graph_predict) + main_b
graph_predict <- graph_predict > 0
graph_answer <- graph_result == " >50K"
graph_accuracy <- graph_predict == graph_answer
graph_accuracy <- sum(graph_accuracy)/length(graph_accuracy)
graph[lambda,(300 * (j - 1) + k)/30] <- graph_accuracy
}
#------------------------------end------------------------------------------------
}#end of 300 steps
valid_predict<-t(t(valid_data)*main_a)
valid_predict<-rowSums(valid_predict) + main_b
valid_predict<-valid_predict > 0
valid_answer <- valid_result == " >50K"
val_accuracy <- valid_predict == valid_answer
val_accuracy <- sum(val_accuracy)/length(val_accuracy)
if(val_accuracy > train_accuracy)
{
train_accuracy <- val_accuracy
result_a <- main_a
result_b <- main_b
}
}#end of 50 epoches
}#end of 10^i
#---------------------start testing now--------------------------------
test_predict<-t(t(test_data)*result_a)
test_predict<-rowSums(test_predict) + result_b
test_predict<-test_predict > 0
test_answer <- test_result == " >50K"
accuracy <- test_predict == test_answer
accuracy <- sum(accuracy)/length(accuracy)
accuracy
#-----------------------------------------------------------------------
#----------------------drawing graph------------------------------------
plot(1:length(graph[1,]),graph[1,],type = "l",	ylab="accuracy",ylim=c(0,1))
lines(1:length(graph[2,]),graph[2,],type = "l",col="red")
lines(1:length(graph[3,]),graph[3,],type = "l",col="green")
lines(1:length(graph[4,]),graph[4,],type = "l",col="gray")
#------------------------end of the program------------------------------
setwd("/Users/Lunan/Desktop/applied_ml/hw2")
rm(list=ls())
library(klaR)
library(caret)
#---------------initialize varablie-----------------------
a <- 0.05
b <- 100
epoch <- 50
step <- 300
train_accuracy <- 0
graph_size = 50 * 300 / 30
graph <- matrix(data=NA,nrow=4,ncol=graph_size)
weight_a<-matrix(data=NA,nrow=4,ncol=epoch)
#--------------------end------------------------------------
#-------------------initialize data----------------------
whole_file <- read.csv('adult.data', header = FALSE)
cont_data <- whole_file[, c(1, 3, 5, 11, 12, 13)]
cont_result <- whole_file[, 15]
#normalization of the data
cont_data<-scale(cont_data)
# separate trainning and validation data
train_ind <- createDataPartition(y = cont_result,p = 0.9,list =FALSE)
train_data <- cont_data[train_ind,]
train_result <- cont_result[train_ind]
valid_data <- cont_data[-train_ind,]
valid_result <- cont_result[-train_ind]
#----------------------end------------------------------------
for(i in 0:-3){
lambda = 10^i
main_a<-runif(6, -2, 2)
main_b<-runif(1, -2, 2)
#print(lambda)
for(j in 1:epoch){
step_len <- 1/(a*j+b)
#-----------------------drawing graph prepare--------------------------
p_rate = 50/nrow(train_data)
graph_idx<-createDataPartition(y = train_result, p = p_rate, list =FALSE)
graph_data <- train_data[graph_idx,]
graph_result <- train_result[graph_idx]
#--------------------------------------------------------------
for(k in 1:step){
select_idx <- sample(1:length(train_data[,1]), 1)
select_data <- train_data[select_idx,]
number<-2*(train_result[select_idx] == " >50K") - 1 #1 for " >50K"; -1 for " <=50K"
predict<-select_data * main_a
predict <- number * (sum(predict) + main_b)
predict <- predict >= 1
if(predict){
grad_a <- lambda * main_a
grad_b <- 0
}
else{
grad_a <- lambda * main_a -  number * select_data
grad_b <- -number
}
main_a <- main_a - grad_a * step_len
main_b <- main_b - grad_b * step_len
#-------------------------------drawing graph data----------------------------
if(k %% 30 == 0)
{
graph_predict <- t(t(graph_data)*main_a)
graph_predict <- rowSums(graph_predict) + main_b
graph_predict <- graph_predict > 0
graph_answer <- graph_result == " >50K"
graph_accuracy <- graph_predict == graph_answer
graph_accuracy <- sum(graph_accuracy)/length(graph_accuracy)
graph[4+i,(300 * (j - 1) + k)/30] <- graph_accuracy
}
#------------------------------end------------------------------------------------
}#end of 300 steps
valid_predict<-t(t(valid_data)*main_a)
valid_predict<-rowSums(valid_predict) + main_b
valid_predict<-valid_predict > 0
valid_answer <- valid_result == " >50K"
val_accuracy <- valid_predict == valid_answer
val_accuracy <- sum(val_accuracy)/length(val_accuracy)
if(val_accuracy > train_accuracy)
{
train_accuracy <- val_accuracy
result_a <- main_a
result_b <- main_b
result_lamda <- i
}
weight_a[i+4,j]<- sqrt(sum(main_a^2))
}#end of 50 epoches
}#end of 10^i
#---------------------start testing now--------------------------------
#load test data
test_data <- read.csv('adult.test', header = FALSE)
test_result <- test_data[, 15]
test_data<-test_data[, c(1, 3, 5, 11, 12, 13)]
test_data<-scale(test_data)
#testing
test_predict<-t(t(test_data)*result_a)
test_predict<-rowSums(test_predict) + result_b
test_predict<-test_predict > 0
test_answer <- test_result == " >50K"
accuracy <- test_predict == test_answer
accuracy <- sum(accuracy)/length(accuracy)
#----------------------graph for accuracy of the model------------------------------------
plot(1:length(graph[1,]),graph[1,],type = "l", xlab="number of steps / 30", ylab="accuracy",ylim=c(0,1))
lines(1:length(graph[2,]),graph[2,],type = "l",col="red")
lines(1:length(graph[3,]),graph[3,],type = "l",col="green")
lines(1:length(graph[4,]),graph[4,],type = "l",col="blue")
legend(380, 0.2, legend=c("位=0.001", "位=0.01", "位=0.1", "位=1" ),
col=c("black","red", "green", "blue"), lty=1:1, cex=0.8)
accuracy
#------------------------end of the program------------------------------
